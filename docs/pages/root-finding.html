<!DOCTYPE html>
<html>
  <head>
    <!-- ! custom meta tags -->
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" />
    <title>Numerical Root Finding</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="author" content="Diego Inácio" />
    <meta
      property="og:url"
      content="https://diegoinacio.github.io/computer-vision-notebooks/pages/root-finding.html"
    />
    <meta
      name="title"
      property="og:title"
      content="Numerical Root Finding >> Computer Vision Notebooks | Diego Inácio"
    />
    <meta
      name="description"
      property="og:description"
      content="Overview and implementation of some numerical methods for root finding."
    />
    <meta
      name="image"
      property="og:image"
      content="https://diegoinacio.github.io/computer-vision-notebooks/images/thumb_root-finding.jpg"
    />
    <meta property="og:image:type" content="image/jpeg" />
    <meta property="og:type" content="article" />
    <meta property="article:author" content="Diego Inácio" />
    <meta property="article:section" content="Computer Vision Notebooks" />
    <!-- /! custom meta tags -->

    <!-- ! custom notebook style -->
    <link rel="stylesheet" href="../assets/css/notebook.css" />
    <!-- /! custom notebook style -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

    <!-- Custom stylesheet, it must be in the same directory as the html file -->
    <link rel="stylesheet" href="custom.css" />

    <!-- Loading mathjax macro -->
    <!-- Load mathjax -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML"></script>
    <!-- MathJax configuration -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"] ],
              displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
              processEscapes: true,
              processEnvironments: true
          },
          // Center justify equations in code and markdown cells. Elsewhere
          // we use CSS to left justify single line equations in code cells.
          displayAlign: 'center',
          "HTML-CSS": {
              styles: {'.MathJax_Display': {"margin": 0}},
              linebreaks: { automatic: true }
          }
      });
    </script>
    <!-- End of mathjax configuration -->
  </head>
  <body>
    <!-- ! custom navbar -->
    <div class="notebook-navbar">
      <a href="http://diegoinacio.github.io/computer-vision-notebooks/">
        Return to <span>Computer Vision Notebooks</span>
      </a>
    </div>
    <!-- /! custom navbar -->
    <div tabindex="-1" id="notebook" class="border-box-sizing">
      <div class="container" id="notebook-container">
        <div class="cell border-box-sizing text_cell rendered">
          <div class="prompt input_prompt"></div>
          <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
              <h1 id="Numerical-Root-Finding">
                Numerical Root Finding<a
                  class="anchor-link"
                  href="#Numerical-Root-Finding"
                  >¶</a
                >
              </h1>
              <hr />
              <ul>
                <li>Author: Diego Inácio</li>
                <li>
                  GitHub:
                  <a href="https://github.com/diegoinacio"
                    >github.com/diegoinacio</a
                  >
                </li>
                <li>
                  Notebook:
                  <a
                    href="https://github.com/diegoinacio/computer-vision-notebooks/blob/master/Mathematical-Foundations/root-finding.ipynb"
                    >root-finding.ipynb</a
                  >
                </li>
              </ul>
              <hr />
              <p>
                Overview and implementation of some numerical methods for
                <em>root finding</em>.
              </p>
              <p>
                <font color="#CC0000">[<b>PT-BR</b> content]</font>
              </p>
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing code_cell rendered">
          <div class="input">
            <div class="prompt input_prompt">In&nbsp;[1]:</div>
            <div class="inner_cell">
              <div class="input_area">
                <div class="highlight hl-ipython3">
                  <pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing text_cell rendered">
          <div class="prompt input_prompt"></div>
          <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
              <p>
                Na matemática, a raiz (ou "<em>zero</em>") de uma função
                polinomial $f(x)$ é todo valor de $x$ em que a mesma função
                intercepta o eixo das abscissas no plano cartesiano, ou seja:
                $f(x)=0$. Geralmente encontramos os valores das raízes de forma
                analítica (ou <em>método direto</em>). Por exemplo, dada uma
                função do primeiro grau $f(x)=2x-2$, podemos obter a equação
                $2x-2=0$ e determinar que a raíz é $1$, já que:
              </p>
              $$ f(1)=2 \cdot 1-2=2-2=0 $$
              <p>
                Se a função for do segundo grau, é possível encontrar (ou não)
                suas raízes por meio de
                <a href="https://pt.wikipedia.org/wiki/Fatora%C3%A7%C3%A3o"
                  >fatoração</a
                >
                ou pela
                <a
                  href="https://pt.wikipedia.org/wiki/Bhaskara_II#A_f%C3%B3rmula_para_encontrar_as_ra%C3%ADzes_da_equa%C3%A7%C3%A3o_quadr%C3%A1tica"
                  >fórmula de Bhaskara</a
                >. Uma função quadrática pode ter até 2 raízes. Ou seja, em
                polinômios, o número de raízes possíveis está ligado ao grau ou
                <em>ordem</em> de uma função. Uma função do segundo grau é um
                polinômio de grau 2 e, desta forma, pode possuir até 2 raízes.
                Um polinômio de grau 3 terá até 3 raízes, um de 4 terá 4 e assim
                por diante. Nem sempre é fácil encontrar o valor de uma raiz de
                forma analítica, pois elas podem não ser exatas. Para isso são
                utilizados métodos numéricos, que visam encontrar o valor da
                raiz por meio de convergência. Para os exemplos a seguir,
                utilizaremos a função:
              </p>
              $$ \large f(x)=\frac{x^3}{4}+\frac{3x^2}{4}-\frac{3x}{2}-2 $$
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing code_cell rendered">
          <div class="input">
            <div class="prompt input_prompt">In&nbsp;[2]:</div>
            <div class="inner_cell">
              <div class="input_area">
                <div class="highlight hl-ipython3">
                  <pre><span></span><span class="c1"># definição da função f(x)</span>
<span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span>
<span class="c1"># raízes adquiridas de forma analítica</span>
<span class="n">raizes</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</pre>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing text_cell rendered">
          <div class="prompt input_prompt"></div>
          <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
              <p>
                Apesar de a função ser de facil solução analítica ou seja, suas
                raízes serem fáceis de serem encontradas de forma direta, iremos
                utilizá-la para fins de estudo e verificação do funcionamento
                dos métodos. A função possui 3 raízes reais, como podem ser
                verificados a seguir.
              </p>
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing text_cell rendered">
          <div class="prompt input_prompt"></div>
          <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
              <p>
                <img
                  src="output/root-finding_analytical.png"
                  alt="root-finding analytical"
                  title="Root-finding Analytical"
                />
              </p>
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing text_cell rendered">
          <div class="prompt input_prompt"></div>
          <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
              <h2 id="1.-Método-da-bissecão">
                1. Método da bissecão<a
                  class="anchor-link"
                  href="#1.-Método-da-bissecão"
                  >¶</a
                >
              </h2>
              <hr />
              <p>
                O
                <a
                  href="https://pt.wikipedia.org/wiki/M%C3%A9todo_da_bisse%C3%A7%C3%A3o"
                  >método da bisseção</a
                >
                funciona com o particionamento de um intervalo inicial $[a,b]$ e
                seguido da seleção do subintervalo que contenha a raiz,
                tornando-o o próximo intervalo a ser bisseccionado. Os valores
                para <strong>a</strong> e <strong>b</strong> serão redefinidos
                com as extremidades do subintervalo e o processo irá se repetir
                até que o valor de uma das extremidades aplicado à função ou
                tamanho do intervalo seja menor que o parâmetro de erro $\large
                \epsilon$. A bisseção é determinada pelo ponto médio entre o
                intervalo, de forma que:
              </p>
              $$ \large x_n=\frac{a+b}{2}, \quad \textrm{para} \quad n=1,2,3
              \ldots $$
              <p>
                O intervalo $[a,b]$ será válido apenas se houver apenas um
                número ímpar de raízes entre ele, caso contrário o algorítmo não
                irá convergir. A verificação da existência de uma raiz entre um
                intervalo qualquer é dada com a verificação da troca de sinais
                entre o mesmo, de forma que:
              </p>
              $$ \large f(a) \cdot f(b) \geq 0 $$
              <p>
                Caso intervalo seja válido, a seleção do subintervalo
                particionado é dada por:
              </p>
              $$ \textrm{Se} \quad f(a) \cdot f(x_n) &lt; 0, \quad
              \textrm{então} \quad b=x_n \quad \textrm{senão} \quad a=x_n $$
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing code_cell rendered">
          <div class="input">
            <div class="prompt input_prompt">In&nbsp;[3]:</div>
            <div class="inner_cell">
              <div class="input_area">
                <div class="highlight hl-ipython3">
                  <pre><span></span><span class="o">%%time</span>
<span class="c1"># parâmetros de entrada</span>
<span class="n">e</span> <span class="o">=</span> <span class="mf">1e-3</span>     <span class="c1"># erro</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span>  <span class="c1"># definição do intervalor [a,b]</span>
<span class="c1"># testes de interválido válido</span>
<span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'Intervalo inválido! "b" deve ser maior do que "a"'</span><span class="p">)</span>
<span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'Intervalo inválido! Não existe raiz ou existem múltiplas raízes entre "a" e "b"'</span><span class="p">)</span>
<span class="c1"># método da bisseção</span>
<span class="n">xn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">])</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">xn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">xn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">xn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">xn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">xn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xn</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'iterações:'</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xn</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">xn</span><span class="p">)</span>
</pre>
                </div>
              </div>
            </div>
          </div>

          <div class="output_wrapper">
            <div class="output">
              <div class="output_area">
                <div class="prompt"></div>

                <div
                  class="output_subarea output_stream output_stdout output_text"
                >
                  <pre>
iterações: 13
[0.         3.         1.5        2.25       1.875      2.0625
 1.96875    2.015625   1.9921875  2.00390625 1.99804688 2.00097656
 1.99951172 2.00024414 1.99987793]
Wall time: 3.49 ms
</pre
                  >
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing text_cell rendered">
          <div class="prompt input_prompt"></div>
          <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
              <p>
                <img
                  src="output/root-finding_bisection.gif"
                  alt="root-finding bisection method"
                  title="Root-finding Bisection Method"
                />
              </p>
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing text_cell rendered">
          <div class="prompt input_prompt"></div>
          <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
              <h2 id="2.-Método-da-falsa-posição">
                2. Método da falsa posição<a
                  class="anchor-link"
                  href="#2.-Método-da-falsa-posição"
                  >¶</a
                >
              </h2>
              <hr />
              <p>
                O
                <a
                  href="https://pt.wikipedia.org/wiki/M%C3%A9todo_da_posi%C3%A7%C3%A3o_falsa"
                  >método da falsa posição</a
                >
                é bastante semelhante ao da <em>bisseção</em>. Ele particiona o
                intervalo e seleciona subintervalos, até que o um intervalo
                selecionado tenha o valor de uma das extremidades menor que o
                erro $\large \epsilon$. A diferença é que, na bisseção, o
                particionamento do intervalo era dado por uma média aritimética
                simples. Já no método da <em>falsa posição</em> a média será
                ponderada com base na extremidade que tiver valor mais próximo à
                raiz. Ou seja, a extremidade que tiver o menor valor. A média
                aritimética ponderada pode ser entendida por:
              </p>
              $$ \large x_n=a-\frac{(b-a) \cdot f(a)}{f(b)-f(a)}, \quad
              \textrm{para} \quad n=1,2,3 \ldots $$
              <p>
                Note que a extremidade que irá convergir será a de menor valor e
                não necessariamente a mais próxima, assim como acontece no
                exemplo a seguir. O critério de escolha da extremidade pode ser
                entendido por:
              </p>
              $$ \textrm{Se} \quad f(a) \cdot f(x_n) &lt; 0, \quad
              \textrm{então} \quad b=x_n \quad \textrm{senão} \quad a=x_n $$
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing code_cell rendered">
          <div class="input">
            <div class="prompt input_prompt">In&nbsp;[4]:</div>
            <div class="inner_cell">
              <div class="input_area">
                <div class="highlight hl-ipython3">
                  <pre><span></span><span class="o">%%time</span>
<span class="c1"># parâmetros de entrada</span>
<span class="n">e</span> <span class="o">=</span> <span class="mf">1e-3</span>     <span class="c1"># erro</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span>  <span class="c1"># definição do intervalor [a,b]</span>
<span class="c1"># testes de interválido válido</span>
<span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'Intervalo inválido! "b" deve ser maior do que "a"'</span><span class="p">)</span>
<span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'Intervalo inválido! Não existe raiz ou existem múltiplas raízes entre "a" e "b"'</span><span class="p">)</span>
<span class="c1"># método da falsa posição</span>
<span class="n">xn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">))])</span>
<span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">xn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">xn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">xn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">xn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">xn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xn</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'iterações:'</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xn</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">xn</span><span class="p">)</span>
</pre>
                </div>
              </div>
            </div>
          </div>

          <div class="output_wrapper">
            <div class="output">
              <div class="output_area">
                <div class="prompt"></div>

                <div
                  class="output_subarea output_stream output_stdout output_text"
                >
                  <pre>
iterações: 11
[0.         3.         0.66666667 1.2972973  1.69565809 1.88220005
 1.95662066 1.98433291 1.99438199 1.99799067 1.99928201 1.99974353
 1.9999084 ]
Wall time: 1.5 ms
</pre
                  >
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing text_cell rendered">
          <div class="prompt input_prompt"></div>
          <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
              <p>
                <img
                  src="output/root-finding_false_position.gif"
                  alt="root-finding false position method"
                  title="Root-finding False Position Method"
                />
              </p>
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing text_cell rendered">
          <div class="prompt input_prompt"></div>
          <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
              <h2 id="3.-Método-Newton-Raphson">
                3. Método Newton-Raphson<a
                  class="anchor-link"
                  href="#3.-Método-Newton-Raphson"
                  >¶</a
                >
              </h2>
              <hr />
              <p>
                O
                <a
                  href="https://pt.wikipedia.org/wiki/M%C3%A9todo_de_Newton%E2%80%93Raphson"
                  >método newton-raphson</a
                >
                (ou <em>método das tangentes</em>) é sem dúvida o método que
                converge mais rápido, porém existe um preço a se pagar por isso.
                O primeiro, assim como nos outros métodos, é necessário saber se
                no intervalo existe uma raiz. O segundo é que, para se obter a
                tangente da função, deve-se ter o conhecimento analítico da
                <em>primeira derivada</em> de $f(x)$, de forma que:
              </p>
              $$ \large x_n=x_{n-1}-\frac{f(x_{n-1})}{f'(x_{n-1})}, \quad
              \textrm{para} \quad n=1,2,3 \ldots $$
              <p>
                Um passo bastante importante para o bom funcionamento do método
                é escolher a melhor extremidade do intervalo $[a,b]$ para
                iniciar o processo. Para isso, faremos uso da
                <em>segunda derivada</em>, de forma que:
              </p>
              $$ f(x_i) \cdot f''(x_i) &gt; 0, \quad \textrm{Para} \quad i=\{
              \textrm{Extremos do intervalo} \} $$
              <p>
                A representação de $f'(x)$ e $f''(x)$ podem ser entendidas,
                respectivamente:
              </p>
              $$ f'(x)=\frac{d}{dx}f(x)=\frac{3x^2}{4}+\frac{3x}{2}-\frac{3}{2}
              \quad ; \quad
              f''(x)=\frac{d}{dx}f'(x)=\frac{d}{dx}\frac{d}{dx}f(x)=\frac{3x}{2}+\frac{3}{2}
              $$
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing code_cell rendered">
          <div class="input">
            <div class="prompt input_prompt">In&nbsp;[5]:</div>
            <div class="inner_cell">
              <div class="input_area">
                <div class="highlight hl-ipython3">
                  <pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span>  <span class="c1"># primeira derivada de f(x) </span>
<span class="n">ddf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span>            <span class="c1"># segunda derivada de f(x)</span>
</pre>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing code_cell rendered">
          <div class="input">
            <div class="prompt input_prompt">In&nbsp;[6]:</div>
            <div class="inner_cell">
              <div class="input_area">
                <div class="highlight hl-ipython3">
                  <pre><span></span><span class="o">%%time</span>
<span class="c1"># parâmetros de entrada</span>
<span class="n">e</span> <span class="o">=</span> <span class="mf">1e-3</span>     <span class="c1"># erro</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span>  <span class="c1"># definição do intervalor [a,b]</span>
<span class="c1"># testes de interválido válido</span>
<span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'Intervalo inválido! "b" deve ser maior do que "a"'</span><span class="p">)</span>
<span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'Intervalo inválido! Não existe raiz ou existem múltiplas raízes entre "a" e "b"'</span><span class="p">)</span>
<span class="c1"># definição do melhor extremo do intervalo</span>
<span class="c1"># xi é equivalente à x_{n-1}</span>
<span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">ddf</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">a</span>
<span class="k">elif</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">ddf</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">b</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'Intervalo inválido! Defina outro intervalo mais preciso'</span><span class="p">)</span>
<span class="c1"># método newton-raphson</span>
<span class="n">xn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">xi</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span><span class="o">/</span><span class="n">df</span><span class="p">(</span><span class="n">xi</span><span class="p">)])</span>
<span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">xn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">xn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xn</span><span class="p">,</span> <span class="n">xi</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span><span class="o">/</span><span class="n">df</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'iterações:'</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xn</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">xn</span><span class="p">)</span>
</pre>
                </div>
              </div>
            </div>
          </div>

          <div class="output_wrapper">
            <div class="output">
              <div class="output_area">
                <div class="prompt"></div>

                <div
                  class="output_subarea output_stream output_stdout output_text"
                >
                  <pre>
iterações: 4
[0.         3.         2.28205128 2.03263278 2.00051927 2.00000013]
Wall time: 998 µs
</pre
                  >
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing text_cell rendered">
          <div class="prompt input_prompt"></div>
          <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
              <p>
                <img
                  src="output/root-finding_newton-raphson.gif"
                  alt="root-finding newton-raphson method"
                  title="Root-finding Newton-Raphson Method"
                />
              </p>
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing text_cell rendered">
          <div class="prompt input_prompt"></div>
          <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
              <h2 id="4.-Método-das-secantes">
                4. Método das secantes<a
                  class="anchor-link"
                  href="#4.-Método-das-secantes"
                  >¶</a
                >
              </h2>
              <hr />
              <p>
                O
                <a href="https://pt.wikipedia.org/wiki/M%C3%A9todo_das_secantes"
                  >método das secantes</a
                >
                é uma opção que geralmente converge mais rapido que o da
                <em>bisseção</em> e não necessita da aquisição analítica da
                derivada, assim como no <em>newton-raphson</em>. Ao invés disso,
                semelhantemente ao método da <em>falsa posição</em>, é utilizado
                o quociente da diferença no lugar de $f'(x)$, de forma que:
              </p>
              $$ \large
              x_{n+1}=x_n-\frac{f(x_n)}{\frac{f(x_n)-f(x_{n-1})}{x_n-x_{n-1}}}=x_n-\frac{(x_n-x_{n-1})
              \cdot f(x_n)}{f(x_n)-f(x_{n-1})}, \quad \textrm{para} \quad
              n=1,2,3 \ldots $$
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing code_cell rendered">
          <div class="input">
            <div class="prompt input_prompt">In&nbsp;[7]:</div>
            <div class="inner_cell">
              <div class="input_area">
                <div class="highlight hl-ipython3">
                  <pre><span></span><span class="o">%%time</span>
<span class="c1"># parâmetros de entrada</span>
<span class="n">e</span> <span class="o">=</span> <span class="mf">1e-3</span>     <span class="c1"># erro</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span>  <span class="c1"># definição do intervalor [a,b]</span>
<span class="c1"># testes de interválido válido</span>
<span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'Intervalo inválido! "b" deve ser maior do que "a"'</span><span class="p">)</span>
<span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'Intervalo inválido! Não existe raiz ou existem múltiplas raízes entre "a" e "b"'</span><span class="p">)</span>
<span class="c1"># método das secantes</span>
<span class="c1"># xo = x_{n-1}</span>
<span class="c1"># xm = x_n</span>
<span class="c1"># xi = x_{n+1}</span>
<span class="n">xo</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">xm</span> <span class="o">=</span> <span class="n">b</span>
<span class="n">xn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xo</span><span class="p">])</span>
<span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">xn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">xm</span> <span class="o">-</span> <span class="p">(</span><span class="n">xm</span> <span class="o">-</span> <span class="n">xo</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">xm</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">xm</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">xo</span><span class="p">))</span>
    <span class="n">xn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xn</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span>
    <span class="n">xo</span> <span class="o">=</span> <span class="n">xi</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'iterações:'</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xn</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">xn</span><span class="p">)</span>
</pre>
                </div>
              </div>
            </div>
          </div>

          <div class="output_wrapper">
            <div class="output">
              <div class="output_area">
                <div class="prompt"></div>

                <div
                  class="output_subarea output_stream output_stdout output_text"
                >
                  <pre>
iterações: 10
[0.         0.66666667 1.2972973  1.69565809 1.88220005 1.95662066
 1.98433291 1.99438199 1.99799067 1.99928201 1.99974353 1.9999084 ]
Wall time: 4.49 ms
</pre
                  >
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="cell border-box-sizing text_cell rendered">
          <div class="prompt input_prompt"></div>
          <div class="inner_cell">
            <div class="text_cell_render border-box-sizing rendered_html">
              <p>
                <img
                  src="output/root-finding_secant.gif"
                  alt="root-finding secant method"
                  title="Root-finding Secant Method"
                />
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
